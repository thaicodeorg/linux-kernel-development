# 03 Netlink Concept ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á

## Netlink ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£? ‡∏ó‡∏≥‡πÑ‡∏°‡πÄ‡∏£‡∏≤‡∏ñ‡∏∂‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏°‡∏±‡∏ô?

‡∏•‡∏≠‡∏á‡∏ô‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏°‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö ‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß Userspace (‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏£‡∏±‡∏ô) ‡∏Å‡∏±‡∏ö Kernel space (‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Ç‡∏≠‡∏á OS) ‡∏°‡∏±‡∏ô‡∏ñ‡∏π‡∏Å‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö

‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö Kernel ‡∏•‡πà‡∏∞? ‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ Kernel ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏´‡πâ Kernel ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏£‡∏≤‡∏£‡∏π‡πâ

‡∏™‡∏°‡∏±‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏≤‡∏°‡∏µ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö:

  * **System Calls:** ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° System Call ‡πÉ‡∏´‡∏°‡πà‡πÜ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô Kernel ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢‡πÜ
  * **`ioctl`:** ‡∏¢‡πà‡∏≠‡∏°‡∏≤‡∏à‡∏≤‡∏Å Input/Output Control ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô ‡πÅ‡∏ï‡πà‡∏Å‡πá‡πÉ‡∏ä‡πâ‡∏¢‡∏≤‡∏Å ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏•‡∏≥‡∏ö‡∏≤‡∏Å ‡πÅ‡∏•‡∏∞‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏ñ‡πâ‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÑ‡∏°‡πà‡∏î‡∏µ
  * **`procfs`/`sysfs`:** ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô `/proc` ‡∏´‡∏£‡∏∑‡∏≠ `/sys` ‡πÉ‡∏´‡πâ Userspace ‡∏≠‡πà‡∏≤‡∏ô/‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ô‡∏µ‡πâ‡∏î‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô ‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏ö‡∏ö Real-time ‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏ä‡πâ‡∏≤‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞

**Netlink** ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡∏Ñ‡∏£‡∏±‡∏ö ‡∏°‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡πÅ‡∏ö‡∏ö **Socket** ‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏™‡∏≠‡∏á‡∏ó‡∏≤‡∏á (Bi-directional) ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Kernel ‡πÅ‡∏•‡∏∞ Userspace

**‡∏Ñ‡∏¥‡∏î‡∏á‡πà‡∏≤‡∏¢‡πÜ:** Netlink ‡∏Ñ‡∏∑‡∏≠ "‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß" ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏≠‡∏á ‡∏ó‡∏µ‡πà‡∏°‡∏µ Kernel ‡πÄ‡∏õ‡πá‡∏ô Server ‡∏´‡∏•‡∏±‡∏Å ‡πÅ‡∏•‡∏∞‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÉ‡∏ô Userspace ‡πÄ‡∏õ‡πá‡∏ô Client ‡∏°‡∏±‡∏ô‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏û‡∏£‡πà‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ô Linux Kernel ‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà (‡πÄ‡∏ä‡πà‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö Network, Firewall, udev ‡∏•‡πâ‡∏ß‡∏ô‡πÉ‡∏ä‡πâ Netlink ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏¥‡πâ‡∏ô)

-----

## 10 ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à Netlink

‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏´‡πâ 10 ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô ‡∏ú‡∏°‡∏à‡∏∞‡πÅ‡∏ö‡πà‡∏á‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Kernel Module ‡πÅ‡∏•‡∏∞ Userspace App ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡∏ú‡πà‡∏≤‡∏ô Netlink ‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô 10 ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô/‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏¢‡πà‡∏≠‡∏¢‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏ô‡∏à‡∏ô‡∏à‡∏ö‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö

**‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤:** ‡∏™‡∏£‡πâ‡∏≤‡∏á Kernel Module ‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "Hello Kernel" ‡∏à‡∏≤‡∏Å Userspace ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤ "Hello Userspace"

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Protocol ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤

Netlink ‡∏°‡∏µ Protocol ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏£‡∏π‡∏õ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß (‡πÄ‡∏ä‡πà‡∏ô `NETLINK_ROUTE` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Network Route) ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Protocol ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß ‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ Protocol ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç 31 ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà

```c
// ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ó‡∏±‡πâ‡∏á Kernel ‡πÅ‡∏•‡∏∞ Userspace
#define NETLINK_USER_PROTOCOL 31
```

- ``NETLINK_USER_PROTOCOL 31``  ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 31, ‡∏ñ‡πâ‡∏≤‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 31 ‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î error "insmod: ERROR: could not insert module netlink_kernel.ko: No child processes"


‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏é‡∏Ç‡πâ‡∏≠‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£: ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏≤‡∏á‡πÑ‡∏´‡∏ô

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: (Kernel) ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Netlink Socket ‡πÉ‡∏ô Module

‡πÄ‡∏°‡∏∑‡πà‡∏≠ Module ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏ñ‡∏π‡∏Å‡πÇ‡∏´‡∏•‡∏î (`insmod`) ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Socket ‡∏ù‡∏±‡πà‡∏á Kernel ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏≤‡∏Å Userspace ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô `netlink_kernel_create`

```c
// ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå kernel module (.c)
#include <net/sock.h> // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö netlink_kernel_create

static struct sock *nl_sk = NULL; // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö socket ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤

static void nl_recv_msg(struct sk_buff *skb); // ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô callback ‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô

static int __init nl_example_init(void) {
    printk("Initializing Netlink Example Module\n");

    // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° config ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á socket
    struct netlink_kernel_cfg cfg = {
        .input = nl_recv_msg, // <-- ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏´‡∏±‡∏ß‡πÉ‡∏à! ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    };

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á socket
    nl_sk = netlink_kernel_create(&init_net, NETLINK_USER_PROTOCOL, &cfg);

    if (!nl_sk) {
        printk(KERN_ALERT "Error creating socket.\n");
        return -10;
    }
    return 0;
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î "‡∏õ‡∏£‡∏∞‡∏ï‡∏π" ‡πÉ‡∏ô‡∏ù‡∏±‡πà‡∏á Kernel ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ö‡∏≠‡∏Å 2 ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠ 1) ‡∏à‡∏∞‡πÉ‡∏ä‡πâ Protocol ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏≠‡∏∞‡πÑ‡∏£ (`NETLINK_USER_PROTOCOL`) ‡πÅ‡∏•‡∏∞ 2) ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ñ‡∏ô‡∏°‡∏≤‡πÄ‡∏Ñ‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡∏ï‡∏π (‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤) ‡∏à‡∏∞‡πÉ‡∏´‡πâ‡πÉ‡∏Ñ‡∏£‡πÑ‡∏õ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ (`.input = nl_recv_msg`)



## Callback ‡∏Ñ‡∏∑‡∏≠‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏ä‡∏¥‡∏á‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå (Event-Driven)

‡πÉ‡∏ô Kernel ‡πÄ‡∏£‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ (‡πÄ‡∏ä‡πà‡∏ô `while(true) { check_for_message(); }`) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏Å‡∏¥‡∏ô CPU ‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡πâ‡∏≤‡∏á

‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ù‡πà‡∏≤‡∏¢ "‡∏ß‡∏¥‡πà‡∏á‡πÑ‡∏õ‡πÄ‡∏ä‡πá‡∏Ñ" ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ö‡∏≠‡∏Å‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡πà‡∏≤:

> "‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏â‡∏±‡∏ô (`nl_recv_msg`) ‡∏ù‡∏≤‡∏Å‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô‡∏ô‡∏∞ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Netlink ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà **‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏£‡∏µ‡∏¢‡∏Å (Call Back)** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏â‡∏±‡∏ô‡∏ó‡∏µ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡πÄ‡∏≠‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡πâ‡∏ô (`skb`) ‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢"

### ‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ üí°

‡∏°‡∏±‡∏ô‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏±‡πà‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏î‡∏•‡∏¥‡πÄ‡∏ß‡∏≠‡∏£‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡πÑ‡∏ß‡πâ‡∏Å‡∏±‡∏ö‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤:
* ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÇ‡∏ó‡∏£‡πÑ‡∏õ‡∏ñ‡∏≤‡∏°‡∏£‡πâ‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÜ 5 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏ß‡πà‡∏≤ "‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏™‡∏£‡πá‡∏à‡∏¢‡∏±‡∏á?" (Active Polling)
* ‡πÅ‡∏ï‡πà‡∏Ñ‡∏∏‡∏ì‡∏ö‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏ß‡πà‡∏≤ "‡∏ñ‡πâ‡∏≤‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß **‡πÇ‡∏ó‡∏£‡∏Å‡∏•‡∏±‡∏ö (Callback)** ‡∏°‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏ö‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏ô‡∏∞"

‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤:
* **‡∏Ñ‡∏∏‡∏ì**: ‡∏Ñ‡∏∑‡∏≠ Kernel Module ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤
* **‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤**: ‡∏Ñ‡∏∑‡∏≠ Netlink Subsystem ‡∏Ç‡∏≠‡∏á Kernel
* **‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå**: ‡∏Ñ‡∏∑‡∏≠ Function Pointer `.input = nl_recv_msg`
* **"‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß"**: ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå (Event) ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Netlink ‡∏™‡πà‡∏á‡∏°‡∏≤‡∏à‡∏≤‡∏Å Userspace

‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠ Design Pattern ‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏ö‡πà‡∏≠‡∏¢‡∏°‡∏≤‡∏Å‡πÜ ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î Kernel ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö Interrupt ‡∏à‡∏≤‡∏Å Hardware, ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ File Operations (open, read, write) ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Network ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏•‡πâ‡∏ß‡∏ô‡πÉ‡∏ä‡πâ Callback ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö

**‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏ñ‡∏π‡∏Å‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö** ‡∏Å‡∏≤‡∏£‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô Concept ‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡πâ‡∏≤‡∏ß‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÇ‡∏Ñ‡πâ‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏•‡∏¢

!!! note
    ‡∏î‡∏π‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• [Ref: Struct netlink_kernel_cfg](./ref01_netlink_kernel_cfg.md)
-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: (Kernel) ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Callback Function)

‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô `nl_recv_msg` ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ú‡∏π‡∏Å‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏´‡πà‡∏≠‡∏´‡∏∏‡πâ‡∏°‡∏°‡∏≤‡πÉ‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö Network ‡∏Ç‡∏≠‡∏á Linux ‡∏ô‡∏±‡πà‡∏ô‡∏Ñ‡∏∑‡∏≠ `struct sk_buff` (‡∏´‡∏£‡∏∑‡∏≠ `skb`)

```c
#include <linux/netlink.h> // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö struct nlmsghdr

static void nl_recv_msg(struct sk_buff *skb) {
    struct nlmsghdr *nlh;
    char *msg;

    printk(KERN_INFO "Entering: %s\n", __FUNCTION__);

    // ‡∏î‡∏∂‡∏á header ‡∏Ç‡∏≠‡∏á Netlink message ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å skb
    nlh = (struct nlmsghdr *)skb->data;
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (payload) ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡∏ó‡πâ‡∏≤‡∏¢ header ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤
    msg = (char *)nlmsg_data(nlh);

    // ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö ‡πÅ‡∏•‡∏∞ PID ‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
    printk(KERN_INFO "Netlink received msg payload: %s\n", msg);
    printk(KERN_INFO "Message sent from PID: %u\n", nlh->nlmsg_pid);

    // ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ...
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ß‡∏¥‡πà‡∏á‡πÉ‡∏ô Netlink ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡∏•‡πà‡∏≤‡πÜ ‡∏°‡∏±‡∏ô‡∏°‡∏µ "‡∏´‡∏±‡∏ß‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢" (`nlmsghdr`) ‡πÅ‡∏õ‡∏∞‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏°‡∏≠ ‡∏ã‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏´‡∏±‡∏ß‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç ‡πÄ‡∏ä‡πà‡∏ô Process ID (PID) ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏≤‡πÉ‡∏Ñ‡∏£

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 4: (Kernel) ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏≤ Userspace ‡πÄ‡∏î‡∏¥‡∏° ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ PID ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏à‡∏≤‡∏Å `nlh->nlmsg_pid`

```c
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô nl_recv_msg ‡∏à‡∏≤‡∏Å‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3
static void nl_recv_msg(struct sk_buff *skb) {
    struct nlmsghdr *nlh;
    int pid;
    struct sk_buff *skb_out;
    char *msg_to_user = "Hello Userspace";
    int msg_size;

    nlh = (struct nlmsghdr *)skb->data;
    pid = nlh->nlmsg_pid; // ‡πÄ‡∏Å‡πá‡∏ö PID ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á

    /* ... ‡πÇ‡∏Ñ‡πâ‡∏î‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° ... */

    // --- ‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö ---
    msg_size = strlen(msg_to_user);

    // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á skb ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
    skb_out = nlmsg_new(msg_size, 0);
    if (!skb_out) {
        printk(KERN_ERR "Failed to allocate new skb\n");
        return;
    }

    // 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á header ‡πÅ‡∏•‡∏∞‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ô skb ‡πÉ‡∏´‡∏°‡πà
    nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, 0);
    // 3. ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÑ‡∏õ‡πÉ‡∏™‡πà‡πÉ‡∏ô payload
    strncpy(nlmsg_data(nlh), msg_to_user, msg_size);

    // 4. ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á Process ‡∏ó‡∏µ‡πà‡∏°‡∏µ PID ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô (Unicast)
    nlmsg_unicast(nl_sk, skb_out, pid);
    printk(KERN_INFO "Sent message back to PID %d\n", pid);
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏Å‡πá‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà ‡∏Ñ‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ã‡∏≠‡∏á (`nlmsg_new`) ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏´‡∏±‡∏ß‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢ (`nlmsg_put`) ‡πÉ‡∏™‡πà‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤ (`nlmsg_data`) ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (`nlmsg_unicast` ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `pid`)

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 5: (Kernel) ‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Socket ‡πÄ‡∏°‡∏∑‡πà‡∏≠ Module ‡∏ñ‡∏π‡∏Å‡∏ñ‡∏≠‡∏î

‡πÄ‡∏°‡∏∑‡πà‡∏≠ Module ‡∏ñ‡∏π‡∏Å‡∏ñ‡∏≠‡∏î‡∏≠‡∏≠‡∏Å (`rmmod`) ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÉ‡∏ä‡πâ‡πÑ‡∏õ ‡∏ô‡∏±‡πà‡∏ô‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Netlink Socket

```c
static void __exit nl_example_exit(void) {
    printk(KERN_INFO "Exiting Netlink Example Module\n");
    netlink_kernel_release(nl_sk); // ‡∏õ‡∏¥‡∏î socket ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÉ‡∏ô Kernel Programming‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏ß‡πâ ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡∏î‡πâ‡∏ß‡∏¢

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 6: (Userspace) ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Socket

‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡∏î‡∏π‡∏ù‡∏±‡πà‡∏á Userspace ‡∏ö‡πâ‡∏≤‡∏á ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏Å‡πá‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Socket ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô ‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡πá‡∏ô Socket family `AF_NETLINK`

```c
// ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå userspace application (.c)
#include <sys/socket.h>
#include <linux/netlink.h>

int sock_fd;
struct sockaddr_nl src_addr;

sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_USER_PROTOCOL);
if (sock_fd < 0) {
    perror("socket");
    return -1;
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Socket ‡πÉ‡∏ô Userspace ‡∏Å‡πá‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Socket ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ ‡πÅ‡∏ï‡πà‡∏£‡∏∞‡∏ö‡∏∏ Family ‡πÅ‡∏•‡∏∞ Protocol ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà Kernel ‡∏£‡∏≠‡∏≠‡∏¢‡∏π‡πà

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 7: (Userspace) ‡∏Å‡∏≤‡∏£ Bind Socket

Kernel ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà Process ‡πÑ‡∏´‡∏ô ‡πÄ‡∏£‡∏≤‡∏à‡∏∂‡∏á‡∏ï‡πâ‡∏≠‡∏á `bind` Socket ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Process ID ‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏£‡∏≤‡πÄ‡∏≠‡∏á

```c
// ‡∏ï‡πà‡∏≠‡∏à‡∏≤‡∏Å‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 6
memset(&src_addr, 0, sizeof(src_addr));
src_addr.nl_family = AF_NETLINK;
src_addr.nl_pid = getpid(); // <-- ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å! ‡πÉ‡∏ä‡πâ PID ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà

if (bind(sock_fd, (struct sockaddr *)&src_addr, sizeof(src_addr)) < 0) {
    perror("bind");
    close(sock_fd);
    return -1;
}
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** `bind` ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£ "‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà" ‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏£‡∏≤‡∏Å‡∏±‡∏ö Kernel ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ PID ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 8: (Userspace) ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° Message ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á

‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ù‡∏±‡πà‡∏á Kernel ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Message ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á Header (`nlmsghdr`) ‡πÅ‡∏•‡∏∞ Payload

```c
#define MAX_PAYLOAD 1024

struct nlmsghdr *nlh;
// ‡∏à‡∏≠‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Header + Payload
nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));
memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));

nlh->nlmsg_len = NLMSG_LENGTH(strlen("Hello Kernel"));
nlh->nlmsg_pid = getpid(); // ‡πÉ‡∏™‡πà PID ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏•‡∏á‡πÉ‡∏ô Header
nlh->nlmsg_flags = 0;

// ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÑ‡∏õ‡πÉ‡∏™‡πà‡πÉ‡∏ô payload
strcpy(NLMSG_DATA(nlh), "Hello Kernel");
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ï‡∏≤‡∏° Format ‡∏Ç‡∏≠‡∏á Netlink ‡πÄ‡∏™‡∏°‡∏≠ ‡πÇ‡∏î‡∏¢‡∏°‡∏µ `nlmsghdr` ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏±‡∏ß ‡πÅ‡∏•‡∏∞‡∏°‡∏µ `NLMSG_DATA` ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏à‡∏£‡∏¥‡∏á‡πÜ

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 9: (Userspace) ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á Kernel

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° Message ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏£‡∏≤‡∏Å‡πá‡∏™‡πà‡∏á‡∏°‡∏±‡∏ô‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏ú‡πà‡∏≤‡∏ô Socket ‡πÇ‡∏î‡∏¢‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠ Kernel (‡∏ã‡∏∂‡πà‡∏á‡∏°‡∏µ `pid` ‡πÄ‡∏õ‡πá‡∏ô 0)

```c
struct sockaddr_nl dest_addr;
struct iovec iov;
struct msghdr msg;

// ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠ Kernel
memset(&dest_addr, 0, sizeof(dest_addr));
dest_addr.nl_family = AF_NETLINK;
dest_addr.nl_pid = 0; // 0 ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á Kernel
dest_addr.nl_groups = 0; // Unicast

iov.iov_base = (void *)nlh; // ‡∏ä‡∏µ‡πâ‡πÑ‡∏õ‡∏¢‡∏±‡∏á message ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á
iov.iov_len = nlh->nlmsg_len;

memset(&msg, 0, sizeof(msg));
msg.msg_name = (void *)&dest_addr;
msg.msg_namelen = sizeof(dest_addr);
msg.msg_iov = &iov;
msg.msg_iovlen = 1;

printf("Sending message to kernel\n");
sendmsg(sock_fd, &msg, 0);
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ä‡πâ `sendmsg` ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏‡∏ó‡∏±‡πâ‡∏á "‡∏à‡∏î‡∏´‡∏°‡∏≤‡∏¢" (`iov`) ‡πÅ‡∏•‡∏∞ "‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö" (`dest_addr`) ‡∏ã‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡∏Å‡πá‡∏Ñ‡∏∑‡∏≠ Kernel (`nl_pid = 0`)

-----

### üéØ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 10: (Userspace) ‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å Kernel

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏Å‡πá‡∏à‡∏∞‡∏£‡∏≠‡∏ü‡∏±‡∏á‡∏ó‡∏µ‡πà Socket ‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å Kernel

```c
// ‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö
printf("Waiting for message from kernel...\n");
recvmsg(sock_fd, &msg, 0); // ‡πÉ‡∏ä‡πâ msghdr ‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ

// ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å kernel
printf("Received message payload: %s\n", (char *)NLMSG_DATA(nlh));

// ‡∏õ‡∏¥‡∏î socket ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô memory
close(sock_fd);
free(nlh);
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≠‡∏ô‡∏≠‡∏∞‡πÑ‡∏£:** ‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡∏≠‡∏á‡∏ó‡∏≤‡∏á ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ Socket ‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏î‡πâ‡∏ß‡∏¢ `recvmsg`

-----

## ‡∏™‡∏£‡∏∏‡∏õ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏° ‡∏ú‡∏°‡πÑ‡∏î‡πâ‡∏£‡∏ß‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏ß‡πâ‡πÉ‡∏´‡πâ‡πÅ‡∏•‡πâ‡∏ß

**`nl_example.c` (Kernel Module)**

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <net/sock.h>
#include <linux/netlink.h>
#include <linux/skbuff.h>

#define NETLINK_USER_PROTOCOL 31

static struct sock *nl_sk = NULL;

static void nl_recv_msg(struct sk_buff *skb) {
    struct nlmsghdr *nlh;
    int pid;
    struct sk_buff *skb_out;
    char *msg_payload;
    char *msg_to_user = "Hello Userspace";
    int res;

    printk(KERN_INFO "Entering: %s\n", __FUNCTION__);

    nlh = (struct nlmsghdr *)skb->data;
    msg_payload = (char *)nlmsg_data(nlh);
    printk(KERN_INFO "Netlink received msg payload: %s\n", msg_payload);
    pid = nlh->nlmsg_pid; // PID ‡∏Ç‡∏≠‡∏á userspace process

    skb_out = nlmsg_new(strlen(msg_to_user), 0);
    if (!skb_out) {
        printk(KERN_ERR "Failed to allocate new skb\n");
        return;
    }

    nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, strlen(msg_to_user), 0);
    strncpy(nlmsg_data(nlh), msg_to_user, strlen(msg_to_user));

    res = nlmsg_unicast(nl_sk, skb_out, pid);
    if (res < 0)
        printk(KERN_INFO "Error while sending back to user\n");
}

static int __init nl_example_init(void) {
    printk("Initializing Netlink Example Module\n");
    struct netlink_kernel_cfg cfg = {
        .input = nl_recv_msg,
    };
    nl_sk = netlink_kernel_create(&init_net, NETLINK_USER_PROTOCOL, &cfg);
    if (!nl_sk) {
        printk(KERN_ALERT "Error creating socket.\n");
        return -10;
    }
    return 0;
}

static void __exit nl_example_exit(void) {
    printk(KERN_INFO "Exiting Netlink Example Module\n");
    netlink_kernel_release(nl_sk);
}

module_init(nl_example_init);
module_exit(nl_example_exit);

MODULE_LICENSE("GPL");
```

**`Makefile` (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Compile Kernel Module)**

```makefile
obj-m += nl_example.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

**`user_app.c` (Userspace Application)**

```c
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/netlink.h>

#define NETLINK_USER_PROTOCOL 31
#define MAX_PAYLOAD 1024

int main() {
    int sock_fd;
    struct sockaddr_nl src_addr, dest_addr;
    struct nlmsghdr *nlh = NULL;
    struct iovec iov;
    struct msghdr msg;

    sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_USER_PROTOCOL);
    if (sock_fd < 0) {
        perror("socket");
        return -1;
    }

    memset(&src_addr, 0, sizeof(src_addr));
    src_addr.nl_family = AF_NETLINK;
    src_addr.nl_pid = getpid();

    if (bind(sock_fd, (struct sockaddr *)&src_addr, sizeof(src_addr)) < 0) {
        perror("bind");
        close(sock_fd);
        return -1;
    }

    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.nl_family = AF_NETLINK;
    dest_addr.nl_pid = 0; // For Kernel
    dest_addr.nl_groups = 0; // unicast

    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));
    memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));
    nlh->nlmsg_len = NLMSG_LENGTH(strlen("Hello Kernel"));
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;

    strcpy(NLMSG_DATA(nlh), "Hello Kernel");

    iov.iov_base = (void *)nlh;
    iov.iov_len = nlh->nlmsg_len;
    
    memset(&msg, 0, sizeof(msg));
    msg.msg_name = (void *)&dest_addr;
    msg.msg_namelen = sizeof(dest_addr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    printf("Sending message to kernel\n");
    sendmsg(sock_fd, &msg, 0);

    printf("Waiting for message from kernel...\n");
    recvmsg(sock_fd, &msg, 0);
    printf("Received message payload: %s\n", (char *)NLMSG_DATA(nlh));

    close(sock_fd);
    free(nlh);
    return 0;
}
```

**‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
```Makefile title="Makefile"

# Compiler ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ (‡∏õ‡∏Å‡∏ï‡∏¥‡∏Ñ‡∏∑‡∏≠ gcc)
CC = gcc

# Flags ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Compiler
# -Wall  -> ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô (Warning) ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
# -Wextra -> ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
# -g     -> ‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Debugging (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö gdb ‡πÑ‡∏î‡πâ)
# -O2    -> ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Optimize ‡πÇ‡∏Ñ‡πâ‡∏î
CFLAGS = -Wall -Wextra -g -O2

# ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (Executable)
TARGET = user_app

# ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ã‡∏≠‡∏£‡πå‡∏™‡πÇ‡∏Ñ‡πâ‡∏î (.c)
SRCS = user_app.c

# --- Targets ---

# Target ‡πÅ‡∏£‡∏Å‡∏™‡∏∏‡∏î‡∏Ñ‡∏∑‡∏≠ default target ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ô "make" ‡πÄ‡∏â‡∏¢‡πÜ
# ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏Å (all) ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå $(TARGET)
all: $(TARGET)

# ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå $(TARGET)
# $(TARGET) ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏à‡∏≤‡∏Å $(SRCS)
$(TARGET): $(SRCS)
	# ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠: gcc [flags] -o [output] [input]
	$(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

# Target ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
clean:
	# ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á rm -f ‡∏Ñ‡∏∑‡∏≠‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á error ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå
	rm -f $(TARGET)

# ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ß‡πà‡∏≤ all ‡πÅ‡∏•‡∏∞ clean ‡πÄ‡∏õ‡πá‡∏ô "phony" targets
# ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏Ñ‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏£‡∏¥‡∏á‡πÜ
.PHONY: all clean

```

1.  **Compile Kernel Module:** `make`
2.  **Compile Userspace App:** `gcc user_app.c -o user_app`
3.  **‡πÄ‡∏õ‡∏¥‡∏î Terminal 2 ‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á**
4.  **Terminal 1:** ‡∏î‡∏π Log ‡∏Ç‡∏≠‡∏á Kernel: `sudo dmesg -w`
5.  **Terminal 2:**
      * ‡πÇ‡∏´‡∏•‡∏î Module: `sudo insmod ./nl_example.ko`
      * (‡πÉ‡∏ô Terminal 1 ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "Initializing Netlink Example Module")
      * ‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° Userspace: `./user_app`
      * (‡πÉ‡∏ô Terminal 2 ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô "Sending message..." ‡πÅ‡∏•‡∏∞ "Received message...")
      * (‡πÉ‡∏ô Terminal 1 ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô Log ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å Kernel)
      * ‡∏ñ‡∏≠‡∏î Module: `sudo rmmod nl_example`
      * (‡πÉ‡∏ô Terminal 1 ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "Exiting Netlink Example Module")

‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏£‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Netlink ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö ‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÑ‡∏õ‡∏™‡∏π‡πà‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô, ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Multicast (Kernel ‡∏™‡πà‡∏á‡∏´‡∏≤‡∏´‡∏•‡∏≤‡∏¢‡πÜ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô), ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Generic Netlink ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏Å‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ
